{"version":3,"sources":["../../src/evaluator/index.js"],"names":["TypedValue","constructor","type","value","objValue","castValue","types","isInteger","BN","isBN","hex","toString","ethers","utils","getAddress","Number","Evaluator","ast","bindings","availableHelpers","provider","providerHost","to","returnType","providers","JsonRpcProvider","DEFAULT_ETH_NODE","helpers","HelperManager","evaluateNodes","nodes","Promise","all","map","evaluateNode","bind","node","evaluatedNodes","body","evaluatedNode","castType","length","Math","ceil","panic","left","right","operator","add","sub","mul","pow","div","mod","leftValue","rightValue","bothTypesAddress","isAddress","bothTypesBytes","bytes","isType","bigNumberify","gt","gte","lt","lte","eq","predicate","leftFalsey","isZero","startsWith","test","target","inputs","outputs","call","abiCoder","encodeFunctionCall","name","callee","input","data","decodeParameter","helperName","exists","result","execute","evaluator","hasOwnProperty","binding","evaluate","flattenedEvaluatedNodes","Array","isArray","reduce","stringReturn","join","msg","Error","options"],"mappings":"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","sourcesContent":["/**\n * @module radspec/evaluator\n */\n\nimport BN from 'bn.js';\nimport flattenDeep from 'lodash.flattendeep';\nimport types from '../types';\nimport HelperManager from '../helpers/HelperManager';\nimport { DEFAULT_ETH_NODE, abiCoder } from '../defaults';\nimport { ethers } from 'ethers';\n\n/**\n * A value coupled with a type\n *\n * @class TypedValue\n * @param {string} type The type of the value\n * @param {*} value The value\n * @property {string} type\n * @property {*} value\n */\nclass TypedValue {\n  constructor(type, value, objValue = null) {\n    this.type = type;\n    this.value = value;\n    this.objValue = objValue;\n\n    this.castValue(type);\n  }\n\n  castValue(type) {\n    if (types.isInteger(type) && !BN.isBN(this.value)) {\n      this.value = new BN(this.value);\n      this.objValue = { hex: `0x${this.value.toString(16)}` };\n    }\n\n    if (type === 'address') {\n      this.value = ethers.utils.getAddress(this.value);\n    }\n\n    if (type === 'string') {\n      this.value = `${this.value}`;\n    }\n\n    if (type === 'number') {\n      this.value = Number(this.value);\n    }\n  }\n\n  /**\n   * Get the string representation of the wrapped value\n   *\n   * @return {string}\n   */\n  toString() {\n    return this.value.toString();\n  }\n}\n\n/**\n * Walks an AST and evaluates each node.\n *\n * @class Evaluator\n * @param {radspec/parser/AST} ast The AST to evaluate\n * @param {radspec/Bindings} bindings An object of bindings and their values\n * @param {?Object} options An options object\n * @param {?Object} options.availablehelpers Available helpers\n * @param {?Web3} options.eth Web3 instance (used over options.ethNode)\n * @param {?string} options.ethNode The URL to an Ethereum node\n * @param {?string} options.to The destination address for this expression's transaction\n * @property {radspec/parser/AST} ast\n * @property {radspec/Bindings} bindings\n */\nexport class Evaluator {\n  constructor(\n      ast,\n      bindings,\n      {\n        availableHelpers = {},\n        provider,\n        providerHost,\n        to,\n        returnType = 'string',\n      } = {}\n  ) {\n    this.provider =\n      provider ||\n      new ethers.providers.JsonRpcProvider(providerHost || DEFAULT_ETH_NODE);\n\n    this.ast = ast;\n    this.bindings = bindings;\n    this.to = to && new TypedValue('address', to);\n    this.helpers = new HelperManager(availableHelpers);\n    this.returnType = returnType;\n  }\n\n  /**\n   * Evaluate an array of AST nodes.\n   *\n   * @param  {Array<radspec/parser/Node>} nodes\n   * @return {Promise<Array<string>>}\n   */\n  async evaluateNodes(nodes) {\n    return Promise.all(nodes.map(this.evaluateNode.bind(this)));\n  }\n\n  /**\n   * Evaluate a single node.\n   *\n   * @param  {radspec/parser/Node} node\n   * @return {Promise<TypedValue>}\n   */\n  async evaluateNode(node) {\n    if (node.type === 'ExpressionStatement') {\n      const evaluatedNodes = await this.evaluateNodes(node.body);\n\n      return evaluatedNodes;\n    }\n\n    if (node.type === 'GroupedExpression') {\n      const evaluatedNode = await this.evaluateNode(node.body);\n\n      if (node.castType) {\n        evaluatedNode.castValue(node.castType);\n      }\n\n      return evaluatedNode;\n    }\n\n    if (node.type === 'MonologueStatement') {\n      return new TypedValue('string', node.value);\n    }\n\n    if (node.type === 'StringLiteral') {\n      return new TypedValue('string', node.value || '');\n    }\n\n    if (node.type === 'NumberLiteral') {\n      return new TypedValue('int256', node.value);\n    }\n\n    if (node.type === 'BytesLiteral') {\n      const length = Math.ceil((node.value.length - 2) / 2);\n      if (length > 32) {\n        this.panic('Byte literal represents more than 32 bytes');\n      }\n\n      return new TypedValue(`bytes${length}`, node.value);\n    }\n\n    if (node.type === 'BoolLiteral') {\n      return new TypedValue('bool', node.value === 'true');\n    }\n\n    if (node.type === 'BinaryExpression') {\n      const left = await this.evaluateNode(node.left);\n      const right = await this.evaluateNode(node.right);\n\n      // String concatenation\n      if (\n        (left.type === 'string' || right.type === 'string') &&\n        node.operator === 'PLUS'\n      ) {\n        return new TypedValue(\n            'string',\n            left.value.toString() + right.value.toString()\n        );\n      }\n\n      // TODO Additionally check that the type is signed if subtracting\n      if (!types.isInteger(left.type) || !types.isInteger(right.type)) {\n        this.panic(\n            `Cannot evaluate binary expression \"${\n              node.operator\n            }\" for non-integer types \"${left.type}\" and \"${right.type}\"`\n        );\n      }\n\n      switch (node.operator) {\n        case 'PLUS':\n          return new TypedValue('int256', left.value.add(right.value));\n        case 'MINUS':\n          return new TypedValue('int256', left.value.sub(right.value));\n        case 'STAR':\n          return new TypedValue('int256', left.value.mul(right.value));\n        case 'POWER':\n          return new TypedValue('int256', left.value.pow(right.value));\n        case 'SLASH':\n          return new TypedValue('int256', left.value.div(right.value));\n        case 'MODULO':\n          return new TypedValue('int256', left.value.mod(right.value));\n        default:\n          this.panic(`Undefined binary operator \"${node.operator}\"`);\n      }\n    }\n\n    if (node.type === 'ComparisonExpression') {\n      const left = await this.evaluateNode(node.left);\n      const right = await this.evaluateNode(node.right);\n\n      let leftValue = left.value;\n      let rightValue = right.value;\n\n      const bothTypesAddress = (left, right) =>\n        // isAddress is true if type is address or bytes with size less than 20\n        types.isAddress(left.type) && types.isAddress(right.type);\n\n      const bothTypesBytes = (left, right) =>\n        types.types.bytes.isType(left.type) &&\n        types.types.bytes.isType(right.type);\n\n      // Conversion to BN for comparison will happen if:\n      // - Both types are addresses or bytes of any size (can be different sizes)\n      // - If one of the types is an address and the other bytes with size less than 20\n      if (bothTypesAddress(left, right) || bothTypesBytes(left, right)) {\n        leftValue = ethers.utils.bigNumberify(leftValue);\n        rightValue = ethers.utils.bigNumberify(rightValue);\n      } else if (!types.isInteger(left.type) || !types.isInteger(right.type)) {\n        this.panic(\n            `Cannot evaluate binary expression \"${\n              node.operator\n            }\" for non-integer or fixed-size bytes types \"${left.type}\" and \"${\n              right.type\n            }\"`\n        );\n      }\n\n      switch (node.operator) {\n        case 'GREATER':\n          return new TypedValue('bool', leftValue.gt(rightValue));\n        case 'GREATER_EQUAL':\n          return new TypedValue('bool', leftValue.gte(rightValue));\n        case 'LESS':\n          return new TypedValue('bool', leftValue.lt(rightValue));\n        case 'LESS_EQUAL':\n          return new TypedValue('bool', leftValue.lte(rightValue));\n        case 'EQUAL_EQUAL':\n          return new TypedValue('bool', leftValue.eq(rightValue));\n        case 'BANG_EQUAL':\n          return new TypedValue('bool', !leftValue.eq(rightValue));\n      }\n    }\n\n    if (node.type === 'TernaryExpression') {\n      if ((await this.evaluateNode(node.predicate)).value) {\n        return this.evaluateNode(node.left);\n      }\n\n      return this.evaluateNode(node.right);\n    }\n\n    if (node.type === 'DefaultExpression') {\n      const left = await this.evaluateNode(node.left);\n      let leftFalsey;\n\n      if (types.isInteger(left.type)) {\n        leftFalsey = left.value.isZero();\n      } else if (left.type === 'address' || left.type.startsWith('bytes')) {\n        leftFalsey = /^0x[0]*$/.test(left.value);\n      } else {\n        leftFalsey = !left.value;\n      }\n\n      return leftFalsey ? this.evaluateNode(node.right) : left;\n    }\n\n    if (node.type === 'CallExpression') {\n      // TODO Add a check for number of return values (can only be 1 for now)\n      let target;\n\n      // Inject self\n      if (node.target.type === 'Identifier' && node.target.value === 'self') {\n        target = this.to;\n      } else {\n        target = await this.evaluateNode(node.target);\n      }\n\n      if (target.type !== 'bytes20' && target.type !== 'address') {\n        this.panic('Target of call expression was not an address');\n      } else if (!ethers.utils.getAddress(target.value)) {\n        this.panic(`Checksum failed for address \"${target.value}\"`);\n      }\n\n      const inputs = await this.evaluateNodes(node.inputs);\n      const outputs = node.outputs;\n\n      const call = abiCoder.encodeFunctionCall(\n          {\n            name: node.callee,\n            type: 'function',\n            outputs,\n            inputs: inputs.map(({ type }) => ({\n              type,\n              name: type,\n            })),\n          },\n          inputs.map(input => input.value)\n      );\n\n      const returnType = outputs[0].type;\n\n      const data = await this.provider.call({\n        to: target.value,\n        data: call,\n      });\n\n      return new TypedValue(\n          returnType,\n          abiCoder.decodeParameter(returnType, data)\n      );\n    }\n\n    if (node.type === 'HelperFunction') {\n      const helperName = node.name;\n\n      if (!this.helpers.exists(helperName)) {\n        this.panic(`${helperName} helper function is not defined`);\n      }\n\n      const inputs = await this.evaluateNodes(node.inputs);\n\n      const result = await this.helpers.execute(helperName, inputs, {\n        provider: this.provider,\n        evaluator: this,\n      });\n\n      return new TypedValue(result.type, result.value, result.objValue);\n    }\n\n    if (node.type === 'Identifier') {\n      if (node.value === 'self') {\n        return this.to;\n      }\n\n      if (!this.bindings.hasOwnProperty(node.value)) {\n        this.panic(`Undefined binding \"${node.value}\"`);\n      }\n\n      const binding = this.bindings[node.value];\n      return new TypedValue(binding.type, binding.value);\n    }\n  }\n\n  /**\n   * Evaluate the entire AST.\n   *\n   * @return {*}\n   */\n  async evaluate() {\n    const evaluatedNodes = await this.evaluateNodes(this.ast.body);\n\n    const flattenedEvaluatedNodes = evaluatedNodes.map(evaluatedNode => {\n      if (Array.isArray(evaluatedNode)) {\n        return flattenDeep(evaluatedNode);\n      }\n\n      return evaluatedNode;\n    });\n\n    if (this.returnType === 'object') {\n      return flattenedEvaluatedNodes.map(evaluatedNode => {\n        if (Array.isArray(evaluatedNode)) {\n          return evaluatedNode.map(({ objValue, value, type }) => ({\n            type,\n            value: objValue || value,\n          }));\n        }\n\n        return {\n          type: evaluatedNode.type,\n          value: evaluatedNode.objValue || evaluatedNode.value,\n        };\n      });\n    }\n\n    return flattenedEvaluatedNodes.reduce((stringReturn, evaluatedNode) => {\n      if (Array.isArray(evaluatedNode)) {\n        return `${stringReturn}${evaluatedNode.join(' ')}`;\n      }\n\n      return `${stringReturn}${evaluatedNode}`;\n    }, '');\n  }\n\n  /**\n   * Report an error and abort evaluation.\n   *\n   * @param  {string} msg\n   */\n  panic(msg) {\n    throw new Error(`Error: ${msg}`);\n  }\n}\n\n/**\n * Evaluates an AST\n *\n * @memberof radspec/evaluator\n * @param {radspec/parser/AST} ast The AST to evaluate\n * @param {radspec/Bindings} bindings An object of bindings and their values\n * @param {?Object} options An options object\n * @param {?string} options.ethNode The URL to an Ethereum node\n * @param {?string} options.to The destination address for this expression's transaction\n * @return {string}\n */\nexport function evaluate(ast, bindings, options) {\n  return new Evaluator(ast, bindings, options).evaluate();\n}\n"],"file":"index.js"}